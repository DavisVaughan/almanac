% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sch-shift.R
\name{sch_jump}
\alias{sch_jump}
\alias{sch_step}
\title{Shift dates relative to a schedule}
\usage{
sch_jump(x, jump, schedule, adjustment = days(1))

sch_step(x, n, schedule)
}
\arguments{
\item{x}{\code{[Date]}

A vector of dates.}

\item{jump}{\code{[Period(1) / character(1)]}

A lubridate period object, such as \code{\link[lubridate:days]{lubridate::days()}} or
\code{\link[lubridate:years]{lubridate::years()}}. This can also be a character string parsable
by \code{\link[lubridate:period]{lubridate::period()}}. Sub-daily periods are not allowed.}

\item{schedule}{\code{[schedule / event]}

A schedule or event.}

\item{adjustment}{\code{[Period(1) / integer(1) / function / formula]}

An adjustment to make whenever a date falls on an event.

If this is a lubridate period object, such as \code{\link[lubridate:days]{lubridate::days()}},
or an integer, then the adjustment is repeatedly applied as
\code{x + adjustment} until the next non-event date is found.

If this is a function or formula (i.e., a lambda function), then it
should accept 2 arguments, the dates to adjust and the original \code{schedule},
and should return a \code{Date} vector of the same size as the original input
containing the adjusted dates. See the functions on the help page for
\code{\link[=adj_following]{adj_following()}} for some examples.}

\item{n}{\code{[integer(1)]}

The number of days to step. Can be negative to step backwards.}
}
\description{
\itemize{
\item \code{sch_jump()} shifts a sequence of dates by "jumping" from \code{x} to
\code{x + jump}. After the jump, \code{\link[=sch_adjust]{sch_adjust()}} is called with the \code{adjustment}
to ensure that if the new dates are events, they are adjusted to the next
available non-event date.
\item \code{sch_step()} steps over a sequence of dates 1 day at a time, for \code{n} days.
After each step, \code{\link[=sch_adjust]{sch_adjust()}} is called with an adjustment of \code{days(1)}.
This has different results from \code{sch_jump()} with a jump of \code{days(n)}, and
is more appropriate for shifting by "n business days".
}

\emph{The performance of \code{sch_step()} in particular is highly dependent on the
\code{since} date used in the schedule's recurrence rules. Choosing a date that
is close to the start of \code{x} can dramatically improve performance.}
}
\details{
For shifting by "n business days", \code{sch_step()} is often more appropriate.
Imagine you are on a Friday and want to shift forward 2 days using a
schedule that marks weekends as events. There are two options:
\itemize{
\item \code{sch_jump()} - Jump forward 2 days to Sunday, and apply the \code{adjustment}.
Assuming \code{adjustment = days(1)} was used, that means the result is Monday.
\item \code{sch_step()} - Step forward 1 day to Saturday, apply an adjustment of
\code{days(1)}, which rolls forward to Monday. Step forward 1 day to Tuesday,
and no further adjustment is required.
}

The second option more naturally lends itself to business logic. Two business
days from Friday is Tuesday.
}
\examples{
# 2019-09-13 is a Friday

# Make a rrule for weekends, and adjust the `since` date to be closer
# to our relevant dates in question
on_weekends <- daily("2019-09-01") \%>\% recur_on_weekends()

# Note that here we "jump" to Sunday, then adjust, leaving us on Monday
sch_jump("2019-09-13", days(2), on_weekends)

# Here we step 1 day to Saturday, adjust to Monday,
# then step 1 day to Tuesday
sch_step("2019-09-13", 2, on_weekends)

}
