% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bdays.R
\name{bdays}
\alias{bdays}
\title{Create a business day period}
\usage{
bdays(x, schedule)
}
\arguments{
\item{x}{\verb{[integer]}

The number of days to step. Can be negative to step backwards.}

\item{schedule}{\verb{[schedule / event]}

A schedule or event.}
}
\description{
\code{bdays()} is similar to \code{\link[lubridate:days]{lubridate::days()}} in that it constructs an object
that can be added to Dates to shift by a set period. It differs in the fact
that you can provide a \code{schedule} to shift relative to.

When using \code{bdays()}, remember that the \code{schedule} defines events that should
be "stepped over". This is powerful, but should be used with some thought,
as it is possible to get into an infinite loop. For example, using a
\code{daily()} schedule with \code{as.Date("2019-01-01") + bdays(1, daily())} would
define every day as an "event" to step over. Since we will never advance to
a non-event day, we get stuck in an endless loop.
}
\details{
When added to a Date, this internally calls \code{\link[=alma_step]{alma_step()}}, meaning that an
adjustment is performed after every 1 day step. This is likely the behavior
that is desired for shifting by "n business days".
}
\examples{
# Create a recurrence rule for weekends
on_weekends <- weekly() \%>\%
  recur_on_weekends()

# A Thursday and Friday
x <- as.Date(c("1970-01-01", "1970-01-02"))

# lubridate::days() just shifts forward by 2 days, without paying
# attention to the weekend
x + days(2)

# With bdays(), you can specify a schedule to step relative to. This steps
# over the weekend, landing us on Monday and Tuesday.
x + bdays(2, on_weekends)

# It is also vectorized, and arithmetic is defined on integer input
business_days <- bdays(2, on_weekends) * c(2, 3)
business_days

x + business_days

x - business_days
}
