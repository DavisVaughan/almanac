---
title: "Grammar"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

{almanac} is based on the iCalendar spec outlined in RFC 5545. Specific sections of inspiration are the definition of a recurrence rule in section 3.3.10, and the recurrence component property section, 3.8.5. Additionally, section 3.8.5.3 provides a large number of recurrence rule examples. {almanac} has the lofty goal of implementing a grammar that can handle all of these examples.

Below I outline the specification for the "recurrence" object type that will be implemented in {almanac}.

# Recurrence

`recur(since = "1970-01-01", frequency = "yearly")`

- Default of `"yearly"` frequency.

- The combination of `since` and `frequency` together make a minimal recurrence object that all methods can be used on.

## since

- Unsure about the default `since` date. Currently going with `"1970-01-01"`.

- Definitely do not want to allow `since = NULL`, which might be learned from some `x` supplied later. That won't work because it would count things like "every 2 weeks" from the min value of `x`, which is arbitrary and would change the recurrence rule based on `x`. Additionally, it would mean we couldn't do `next_event()` because we would have no start date stored.

### since alignment

- TODO - Generally, `since` is aligned with the 1st occurrence of an event in the recurrence. The specification requires that this is the case, but I think that we might relax this, and have some rule to "find" the first occurrence instead, creating an "effective" start date.
  - For example, "the first tuesday of the month", but we specified:
    - `since = "2019-09-01"`
      - A sunday, and before the first tuesday
      - First tuesday of the month is on "2019-09-03", this is the effective start date
    - `since = "2019-09-04"`
      - A wednesday, and after the first tuesday
      - What to do here? Two options:
        - Since `frequency = "monthly"`, we could `floor_date(unit = "month")` to get to `"2019-01-01"` then use that to find the first tuesday of the month, "2019-09-03"
        - Since we are already past the first tuesday of September, we go forward to the first tuesday of October, `"2019-10-01"`. 
  

  
## Parameters

- `since`: A `Date` object representing the anchor point of the recurrence.

- `frequency`: A single character representing the type of recurrence. This is a required parameter to construct a minimal recurrence object.

- `until` and `times` are not parameters here, as they are optional and mutually exclusive. They are supplied afterwards with `until(x)` and `for_times(x)` if required.

## Object internals

- `since`
  - ptype: `Date` or `POSIXct` 
  - size: `1L`
  - default: `"1970-01-01"`
  - The start date of the recurrence
  - Required
  - Inclusive
  - If no `until` or `count` is supplied, the recurrence is assumed to be infinite.

- `frequency`
  - ptype: `character`
  - size: `1L`
  - default: `"yearly"`
  - The type of recurrence
  - Required
  - One of:
    - Secondly, Minutely, Hourly, Daily, Weekly, Monthly, Yearly
  - Only 1 frequency can be specified per recurrence rule.

- `until`
  - ptype: `Date` or `POSIXct`
    - But the same as `start`, or castable to it.
    - Same time zone as `start`.
  - size: `1L`
  - default: `NULL`
  - The stop date of the recurrence
  - Inclusive
  - Optional
    - Mutually exclusive with `times`

- `times`
  - ptype: `integer`, > 0
  - size: `1L`
  - default: `NULL`
  - The maximum number of times a recurrence is allowed to occur
  - Optional
    - Mutually exclusive with `until`

- `interval`
  - ptype: `integer`, > 0
  - size: `1L`
  - default: `1L`
  - The interval at which a recurrence repeats
  - Optional

- `second`
  - ptype: `integer`, 0:59
  - size: vector, size of 0-60
  - default: `NULL`
  - The seconds within a minute to recur on.
  - On the way in, values are taken as unique and sorted
  - TODO - For second/minute/hour: If `since == Date`
    - We could promote `since` to a POSIXct with UTC time zone
    - We could error
  
- `minute`
  - ptype: `integer`, 0:59
  - size: vector, size of 0-60
  - default: `NULL`
  - The minutes within an hour to recur on.
  - On the way in, values are taken as unique and sorted

- `hour`
  - ptype: `integer`, 0:23
  - size: vector, size of 0-24
  - default: `NULL`
  - The hours within a day to recur on.
  - On the way in, values are taken as unique and sorted
  
- `wday`
  - ptype: `named list`
  - size: `1L`
  - default: `list()`
  - values are added to the list in the form of: 
    - `c(wday_list, list(monday = NULL))`
    - `c(wday_list, list(monday = c(1, 2)))`
    - `c(wday_list, list(friday = -1))`
  - The weekdays to recur on.
  - The value of each list element is named, and allowed to be:
    - `NULL` - All elements of the wday within the frequency
    - `+n` - The n-th element of the wday within the frequency (first monday of the month)
    - `-n` - The n-th element of the wday from the end of the frequency (last sunday of the year)
  - See `on_wday()` for more details
  
- `mday`
  - ptype: `integer`, 1:31, or negative values
  - size: vector, max size of 62
  - default: `NULL`
  - The days within a month to recur on.
  - On the way in, values are taken as unique and sorted
  - See `on_mday()` for more details

- `yday`
  - ptype: `integer`, 1:366, or negative values
  - size: vector, max size of 366*2
  - default: `NULL`
  - The days within a year to recur on.
  - On the way in, values are taken as unique and sorted
  - See `on_yday()` for more details

- `yweek`
  - ptype: `integer`, 1:53, or negative values
  - size: vector, max size of 53*2
  - default: `NULL`
  - The week number within a year to recur on.
  - On the way in, values are taken as unique and sorted
  - See `on_yweek()` for more details

- `ymonth`
  - ptype: `integer / character`, 1:12, also accepts Jan/Feb/.../Dec
  - size: vector, max size of 12
  - default: `NULL`
  - The month within a year to recur on.
  - Negative values are not allowed
  - On the way in, values are taken as unique and sorted
  - See `on_ymonth()` for more details

- `occurence_position`

- `week_start`
  - ptype: `integer / character`, 1:7, also accepts Mon/.../Sun
  - size: 1
  - default: `7` (Sunday in lubridate)
    - `floor_date(as.Date("2019-09-16"), "weeks", 7)`
  - The day of the week to start on.

### Potential other internals

Note: Internals which take a vector, like `mday`, should take the union of their values if called multiple times, like with `on_mday(3) %>% on_mday(2)`.

## recur_*()

`recur_secondly()`
`recur_minutely()`
`recur_hourly()`
`recur_daily()`
`recur_weekly()`
`recur_monthly()`
`recur_yearly()`

maybe `recur_quarterly()`

- "Every year" `recur_yearly()`
  - 1 date per year (if it exists)
  - `since + years(n)`
  - Keeps same month / day of month / time as `since`
- "Every month" `recur_monthly()`
  - 1 date per month
  - 12 dates per year
  - `since + months(n)`
  - Keeps same day of month / time as `since`
- "Every week" `recur_weekly()`
  - 1 date per week
  - 52 ish dates per year
  - `since + weeks(n)`
  - Keeps same day of week / time as `since`
- "Every day" `recur_daily()`
  - 1 date per day
  - 365 dates per year

## until()

- Mutually exclusive with `times()`

- Can only be called once per rule

## times()

- Mutually exclusive with `until()`

- Can only be called once per rule

## interval()

- Default of 1 means:
  - Secondly: Every second of the minute
  - Minutely: Every minute of the hour
  - Hourly: Every hour of the day
  - Daily: Every day of the year
  - Week: Every week of the year
  - Month: Every month of the year
  - Yearly: Every year

- Can only be called once per rule

- Helps with the questions
  - "Every 2nd month"
  - "Every 4th year on mondays"
  - i.e. any question at the n-th "frequency" level
  
## on_wday()

`on_wday(x, nth = NULL)`

- x = character, a single valid weekday
- nth = NULL / integer vector

- If called repeatedly as `on_wday("Mon", 1) %>% on_wday("Mon", 2)`, error. Because this would not make sense:
  - `on_wday("Mon", nth = NULL) %>% on_wday("Mon", nth = 2)`
  - Start with all mondays within the frequency, then reduce to only the 2nd one? Doesn't make sense!

- YEARLY
  - Nothing else set:
    - "Every monday in the year": `recur_yearly() %>% on_wday("Mon")`
    - "First tuesday in the year": `recur_yearly() %>% on_wday("Mon", 1)`
    - "Last saturday in the year": `recur_yearly() %>% on_wday("Sat", -1)`
  - `on_month()` also set:
    - Becomes an offset within the month
    - "Every monday in February": `recur_yearly() %>% on_month("Feb") %>% on_wday("Mon")`
    - "First monday in February": `recur_yearly() %>% on_month("Feb") %>% on_wday("Mon", 1)`
    - "Last monday in February": `recur_yearly() %>% on_month("Feb") %>% on_wday("Mon", -1)`
    - "First and third monday in February and July": `recur_yearly() %>% on_month(c("Feb", "July)) %>% on_wday("Mon", c(1, 3))`
- MONTHLY
  - Nothing else set:
    - "Every monday in every month": `recur_monthly() %>% on_wday("Mon")`
    - "Last sunday in every month": `recur_monthly() %>% on_wday("Sun", -1)`
    - "First and last sunday in every month": `recur_monthly() %>% on_wday("Sun", c(1, -1))`

- ERRORS:
  - If `frequency != "yearly" || frequency != "monthly"`, cannot be set with a numeric `nth` value.
    - Think about:
      - `recur_weekly() %>% on_wday("Tues")`, this is fine
      - `recur_weekly() %>% on_wday("Tues", 2)`, this would not make sense:
  - If `frequency == "yearly"` and `on_yweek()` has been set, cannot be set with a numeric `nth` value.
    - Think about:
      - `recur_yearly() %>% on_yweek(1) %>% on_wday("Tues")`, this is fine
      - `recur_yearly() %>% on_yweek(1) %>% on_wday("Tues", 2)`, this would never make sense

Outside the specification, but think about:

- QUARTERLY
  - `on_quarter()` also set:
    - Becomes an offset within the quarter
    - "Every monday in Q1": `recur_yearly() %>% on_quarter(1) %>% on_wday("Mon")`
    - "First monday in Q1": `recur_yearly() %>% on_quarter(1) %>% on_wday("Mon", 1)`
    - "First and third monday in Q1 and Q3": `recur_yearly() %>% on_quarter(c(1, 3)) %>% on_wday("Mon", c(1, 3))`

## on_mday()

`on_mday(x)`

- x:
  - A vector of integers
  - Positive values are days from the start of the month
  - Negative values are days from the end of the month
  
- YEARLY
  - "2nd day of the month, every year": `recur_yearly() %>% on_mday(2)`
  - "The first monday of each year, which also happens to occur on the first day of the month": `recur_yearly() %>% on_wday("Mon") %>% on_mday(1)`
  - "last day in every month": `recur_yearly() %>% on_mday(-1)`
  - "last day in February": `recur_yearly() %>% on_month("Feb") %>% on_mday(-1)`
    - Happens without any special behavior, unlike `on_wday()`
- MONTHLY
  - "2nd day of the month, every month": `recur_monthly() %>% on_mday(2)`
    - In this case, same as `recur_yearly()`?
  - "The first monday of each month, which also happens to occur on the first day of the month": `recur_monthly() %>% on_wday("Mon") %>% on_mday(1)`
    - Notice how this is different from `recur_yearly()`

- ERRORS
  - If `frequency == "weekly"`, cannot be used.

Outside the specification, but think about:

- QUARTERLY
  - "2nd day in every quarter": `recur_quarterly() %>% on_mday(2)`
    - In this case, same as `recur_yearly()`
  - "The first monday of each quarter, which also happens to occur on the first day of the month": `recur_quarterly() %>% on_wday("Mon") %>% on_mday(1)`
    - Notice how this is different from `recur_yearly()`

## on_yday()

`on_yday(x)`

- x:
  - A vector of integers
  - Positive values are days from the start of the year
  - Negative values are days from the end of the year
  
- ERRORS
  - If `frequency == "daily"`, cannot be used.
  - If `frequency == "weekly"`, cannot be used.
  - If `frequency == "monthly"`, cannot be used.
  
- Not in the specification, but if:
  - If `frequency == "quarterly"`, cannot be used.

- YEARLY
  - "First day of the year": `recur_yearly() %>% on_yday(1)`
  - "Last day of the year": `recur_yearly() %>% on_yday(-1)`
  - "First day of the year, every other year": `recur_yearly() %>% on_interval(2) %>% on_yday(1)`
  - "2nd day of the year, that also happens to be a Monday": `recur_yearly() %>% on_yday(2) %>% on_wday("Monday")`
- HOURLY
  - "Every hour on the 2nd day of the year": `recur_hourly() %>% on_yday(2)`


## on_yweek()

`on_yweek(x)`

- A week is defined as a 7 day period.
- Starting on the day of the week defined by `week_start`.

- Week 1 of the calendar year is the first week that contains at least 4 days in that calendar year, starting on `week_start`.
  - Meaning if `week_start = Monday`
    - If January 1 falls on a Friday, then it belongs to the last week of the previous year. Week 1 would start on the following Monday, January 4th.
    - If December 31 falls on a Wednesday, then it belongs to week 1 of the following year. Week 1 would start on December 29th.
    - Algo to find the correct week number for a date http://myweb.ecu.edu/mccartyr/ISOwdALG.txt

- x:
  - A vector of integers
  - Positive values are weeks from the start of the year
  - Negative values are weeks from the end of the year

- ERRORS
  - If `frequency != "yearly"` then error.
  
## on_ymonth()

`on_ymonth(x)`

- x:
  - A vector of integers / characters
  - Months of the year

- YEARLY
  - "Every `since` date in Jan and Feb": `recur_yearly() %>% on_ymonth(c("Jan", "Feb"))`
    - This expands.
    - From every `since + years(n)` -> `since-with-Jan-month + years(n)`, `since-with-Feb-month + years(n)`
       - Takes it from 1 day a year, to 2 days per year
  - "Every January on the last Friday of the month": `recur_yearly() %>% on_ymonth("Jan") %>% on_wday("Friday", -1)`
  - "Every January on the last Friday of the month that is also the 50th day of the year": `recur_yearly() %>% on_ymonth("Jan") %>% on_wday("Friday", -1) %>% on_yday(50)`
    - So we can't actually change it to a monthly frequency, because this would not be allowed, can't mix yday with monthly:
    - `recur_monthly() %>% on_ymonth("Jan") %>% on_wday("Friday", -1) %>% on_yday(50)`
  - "Every other January": `recur_yearly() %>% on_interval(2) %>% on_ymonth("Jan")`
- MONTHLY
  - "Every January": `recur_monthly() %>% on_ymonth("Jan")`
    - This limits.
    - Every `since + months(n)` date -> Every `since + months(n)` date that also occurs in January.
- DAILY
  - `recur_daily() %>% on_ymonth("Jan")`
    - This limits
    - From every `since + days(n)` date -> Every `since + days(1)` date that also occurs in January
  
## with_week_start()
  
`with_week_start(x)`

- x:
  - A single integer / character
  - Day of the week to start the work week on

- Significant when:
  - `recur_weekly() %>% on_interval(2) %>% on_wday("Tues")`
  - `recur_yearly() %>% on_yweek(2)` (What day of the week to start a week on?)

## on_occurrence()

`on_occurrence(x)`

- x:
  - A single integer
  - Positive - The n-th occurrence of the rule
  - Negative - The n-th occurrence of the rule from the end

- ERRORS
  - If no other `on_*()` function has been specified, error.
  
- Operates on 1 interval of the recurrence rule at the `frequency` level.

- MONTHLY
  - "The last workday of the month": 
    - `recur_monthly() %>% on_wday(Mon) %>% on_wday(Tues) %>% on_wday(Wed) %>% on_wday(Thur) %>% on_wday(Fri) %>% on_occurrence(-1)`
    - Take a single month
    - Find every Monday:Friday date
    - Take the last one

## Invalid dates

Some recurrence rules can generate invalid dates, like February 30th.
`recur_monthly(since = "1970-01-31")`

These instances must be ignored and must not be attempted to be counted in the recurrence set.

## Order of rules

1) `frequency` and `interval`

2) `on_month()`

3) `on_yweek()`

4) `on_yday()`

5) `on_mday()`

6) `on_wday()`

7) `on_hour()`

8) `on_minute()`

9) `on_second()`

10) `on_occurrences()`

11) `times()`, `until()`

## Examples - Daily

```{r}
library(lubridate)
library(vctrs)
```


Daily for 10 occurrences

```{r, eval=FALSE}
start <- as.Date("1997-09-02 09:00:00")

recur_daily(start) %>% times(10)

start + days(0:9)
```

Daily until Dec 24, 1997

```{r, eval=FALSE}
start <- as.Date("1997-09-02 09:00:00")
until <- as.Date("1997-12-24 00:00:00")

recur_daily(start) %>% until(until)

days_between <- interval(start, until) / days(1)

start + days(0:(days_between - 1))
```

Every other day, forever

```{r, eval=FALSE}
start <- as.Date("1997-09-02 09:00:00")

recur_daily(start) %>% on_interval(2)

start + days(seq(0, 10, by = 2))
```

Every 10 days, 5 occurrences

```{r, eval=FALSE}
start <- as.Date("1997-09-02 09:00:00")

recur_daily(start) %>% on_interval(10) %>% times(5)

start + days(seq(0, 40, by = 10))
```

Every day in January, for 3 years

Two ways to do this:

- `recur_yearly(start) %>% until(until) %>% on_month("January") %>% on_wday(Sun:Sat)`
  - "On every year" `recur_yearly(start)`, equal to `since + years(n)`
    - 1 day per year
  - "On every year, where the month is January" `recur_yearly(start) %>% on_month("January")`
    - 1 day per year (expand)
  - "On every year, where the month is January, and the weekday is Sun:Sat `recur_yearly(start) %>% on_month("January") %>% on_wday(Sun:Sat)`
    - 31 days per year (expand)
  - "On every year, where the month is January, and the weekday is Sun:Sat, until `until`
  
- `recur_daily() %>% on_month("Jan") %>% until(until)`
  - "On every day" `recur_daily()` (`since + days(n)`)
    - 365-ish days per year
  - "On every day, in the month of January" `recur_daily() %>% on_month("Jan")`
    - 31 days per year (limit)
  - "On every day, in the month of January, until `until`

```{r, eval=FALSE}
start <- as.Date("1997-08-01 09:00:00")
until <- start + years(3)

recur_daily(start) %>% until(until) %>% on_month("January")

recur_yearly(start) %>% until(until) %>% on_month("January") %>% on_wday(Sun:Sat)
```

## Examples - Weekly

Weekly, for 10 occurrences

```{r, eval=FALSE}
start <- as.Date("1997-09-02 09:00:00")

recur_weekly(start) %>% times(10)

start + weeks(0:9)
```

Weekly until Dec 24, 1997

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-02 09:00:00")
until <- as.POSIXct("1997-12-24 00:00:00")

recur_weekly(start) %>% until(until)

start + weeks(0:16)
```

Every other week, forever

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-02 09:00:00")

recur_weekly(start) %>% on_interval(2)

start + weeks(seq(0, 25, by = 2))
```

Weekly on tuesday and thursday for 5 weeks

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-02 09:00:00") # a tuesday
until <- start + weeks(5)

recur_weekly(start) %>% until(until) %>% on_wday("Tues") %>% on_wday("Thurs") %>% with_week_start("Sunday")

# or
recur_weekly(start) %>% times(10) %>% on_wday("Tues") %>% on_wday("Thurs") %>% with_week_start("Sunday")

wday(start, T)
sort(vec_c(start + weeks(0:4), start + days(2) + weeks(0:3)))
```

Every other week on Monday / Wednesday / Friday until Dec 24 1997

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-01 09:00:00") # a monday
until <- as.POSIXct("1997-12-24 00:00:00")

recur_weekly(start) %>% until(until) %>% on_wday("Mon") %>% on_wday("Wed") %>% on_wday("Fri") %>% on_interval(2) %>% with_week_start("Sunday")

start + weeks(seq(0, 16, by = 2))
start + days(2) + weeks(seq(0, 14, by = 2))
start + days(4) + weeks(seq(0, 14, by = 2))
```

What if, outside the spec, we had been given:

```{r}
# before monday
bad_start <- as.Date("1997-08-31")

wday(bad_start, T)

# find next effective start date:
ceiling_date(bad_start, "weeks", week_start = 1) # 1 = monday
```

```{r}
# tuesday after monday
bad_start2 <- as.Date("1997-09-02")

wday(bad_start2, T)

# find next effective start date:
ceiling_date(bad_start2, "weeks", week_start = 3) # 1 = wednesday
```

Every other week on Tues Thurs for 8 occurrences

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-02 09:00:00")

recur_weekly() %>% on_wday("Tues") %>% on_wday("Thurs") %>% times(8) %>% on_interval(2)
```

## Examples - Monthly

Monthly on the first friday for 10 occurrences

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-05 09:00:00") # a friday

recur_monthly() %>% on_wday("Friday", 1) %>% times(10)
```


Every other month on the first and last sunday of the month for 10 occurrences

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-07 09:00:00") # a sunday

recur_monthly() %>% on_wday("Sunday", c(1, -1)) %>% times(10) %>% on_interval(2)
```

Monthly on the second to last monday in the month, for 6 months

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-22 09:00:00") # a second to last monday

recur_monthly() %>% on_wday("Monday", -2) %>% times(6)

recur_monthly() %>% on_wday("Monday", -2) %>% until(start + months(6))


```

What if we had been given a bad day?

- Adjustment would happen at the top level, not inside `on_wday` or anything. It needs to be able to see every rule in the recurrence.

```{r, eval=FALSE}
start <- as.Date("1997-09-14") # not a second to last monday
wday(start, T)

# - day of the week is wrong
#   - adjust to monday by adding N days (monday is wday 2, sunday is wday 1)
#   - days_from_monday <- 2 - wday("1997-09-14", week_start = 7)
#   - days_from_monday <- if (days_from_monday < 0) {7 - days_from_monday} else {days_from_monday}
#   - as.Date("1997-09-14") + days(days_from_monday)
#   - 1997-09-15
# - week of month is wrong
#   - adjust to second to last week of month by adding N weeks
```

Monthly on the third-to-last day of the month, forever

```{r, eval=FALSE}
start <- as.POSIXct("1997-09-28 09:00:00") # third to last day of the month

recur_monthly() %>% on_mday(-3)
```


## Non-recurrence defining API

The rest of the API that I want to have:

```{r}
# Combine recurrence rules

# "Every year on labor day or on christmas"
r1 <- recur_yearly() %>% on_month("December") %>% on_mday(25) 
r2 <- recur_yearly() %>% on_month("Sept") %>% on_wday("Monday", 1) 

# Union recurrence rule
# - Still another recurrence rule
# - Should contain rules r1 and r2 in it
r3 <- r1 | r2

r1 & r2 # intersect (hard?)
r1 | r2 # union
r1 - r2 # difference (hard?)
!r1 # negate


```


```{r}
# Next N occurrences after `from` (uses `since` if NULL)
# If no rule has a `times` set, we can jump straight to `from`, otherwise
# we have to compute the full occurrence set
event_next(schedule, from = NULL, n = 1L)

# Last N occurrences before `from`
# (would not use `since`, as then it would just look backwards)
event_previous(schedule, from, n = 1L)

# Find all occurences between two times
event_between(schedule, from, to)

# Find all events in a schedule
# (require that it terminates == has times / until conditions set)
event_all(schedule)

# Is the vector of dates `x` in the schedule?
# Under the hood would use:
# - events <- event_between(schedule, from = min(x), to = max(x))
#   - event_between() would be optimized to start from min(x) if there is no `times` arg set in the schedule
# - vec_in(x, events)
event_in(x, schedule)
```

```{r}
event_next <- function(schedule, from = NULL, n = 1L) {
  event_find(schedule, from = from + 1, to = NULL, n = n)
}

event_previous <- function(schedule, from, n = 1L) {
  tail(event_find(schedule, from = NULL, to = from - 1, n = NULL), 1L)
}

event_between <- function(schedule, from, to) {
  event_find(schedule, from = from, to = to)
}

# - will use `since` date
# - if `times` is set, will use that for `n`
# - if `until` is set, will use that for `to`
# - if neither are set, will error with a terminating requirement
event_all <- function(schedule) {
  event_find(schedule, from = NULL, to = NULL, n = NULL)
}

event_find <- function(schedule, from = NULL, to = NULL, n = NULL) {
  if (is.null(from)) {
    from <- schedule$since
  }
  
  if (is.null(to)) {
    to <- schedule$until
  }
  
  if (is.null(n)) {
    n <- schedule$times
  }
  
  if (from > to) {
    abort()
  }
  
  # if n == NULL, this means find all events.
  # - if to == NULL, require terminating
  # - if to != NULL, should be okay
  
  # what to do if we are supposed to find 4 events, but only 3 exist?
  # maybe n is the max number we can find
  
  count <- 0L
  current_date <- NULL
  finished <- FALSE
  
  # FIND EVENT LOOP
  while(!finished) {
    for (rule in schedule$rules) {
      current_until <- current_date %||% to
      
      # the current rule provided this as the next possible date
      possible_date <- rule_next(rule, from, schedule$since, current_until)
      
      current_date <- min(current_date, possible_date)
    }
    
    finished <- finished_n(count, n) || finished_to()
  }
}

finished_n <- function(count, n) {
  if (is.null(n)) {
    return(FALSE)
  }
  
  count == n
}


```

## Other questions we want to answer

Trash day normally comes on friday, unless friday is a holiday, in which case it comes on the next non-event date.

```{r}
on_normal_trash_day <- recur_weekly() %>% on_wday("Friday")

friday_holiday_day <- recur_yearly() %>% on_wday("Friday", 1) %>% on_month("Sept")
weekends <- recur_yearly() %>% on_weekend()
holidays <- friday_holiday_day | christmas | weekends

# recur_unless(on_normal_trash_day, holidays, !holidays)
recur_unless(on_normal_trash_day, event = holidays, alternative = !event)

# Friday - 09/08
# - Yes normal trash day
# - No, not holiday
# - Done, trash day

# Friday - 09/01
# - Yes normal trash day
# - Yes holiday
# - Next non-event date, by default, next non holiday
#   - which maybe must also occur before the next trash day?

# Monday - 09/04
# - No not trash day
# -...
```





